/*
	Freetronics Dot Matrix Display Driver Code
	
	Based off the dmd_demo example provided by freetronics.
	
	Authors:	Mark Jessop (vk5qi(at)rfhead(dot)net)
	Date: 2012-05-05
	
	
	IMPORTANT: This code requires modification of the DMD library.
	You will need to move the bDMDScreenRAM declaration OUT of the private area, so we can
	write to it directly.
	
	
	Blah blah, GPLv3 blah blah.

*/
#include <SPI.h>        //SPI.h must be included as DMD is written by SPI (the IDE complains otherwise)
#include <DMD.h>        //
#include <TimerOne.h>   //
#include "SystemFont5x7.h"
#include "Arial_black_16.h"

//Fire up the DMD library as dmd
#define DISPLAYS_ACROSS 1
#define DISPLAYS_DOWN 1
DMD dmd(DISPLAYS_ACROSS, DISPLAYS_DOWN);

/*--------------------------------------------------------------------------------------
  Interrupt handler for Timer1 (TimerOne) driven DMD refresh scanning, this gets
  called at the period set in Timer1.initialize();
--------------------------------------------------------------------------------------*/
void ScanDMD(){ 
  dmd.scanDisplayBySPI();
}

// Interrupt enable/disable helper functions, in an attempt to reduce flicker
// by stopping concurrent access. Doesn't work.
void disable_refresh(){
	Timer1.detachInterrupt();
}
void enable_refresh(){
	Timer1.attachInterrupt( ScanDMD ); 
}

void setup(void){
	pinMode(2, INPUT);
	// Set a seed value for the random number stuff we might be using later.
	randomSeed(analogRead(0));

   //initialize TimerOne's interrupt/CPU usage used to scan and refresh the display
   Timer1.initialize( 5000 );           //period in microseconds to call ScanDMD. Anything longer than 5000 (5ms) and you can see flicker.
   Timer1.attachInterrupt( ScanDMD );   //attach the Timer1 interrupt to ScanDMD which goes to dmd.scanDisplayBySPI()

   //clear/init the DMD pixels held in RAM
   dmd.clearScreen( true );   //true is normal (all pixels off), false is negative (all pixels on)
}



// Pixellated Hackerspace Adelaide Logo. Sorry Simon :-(
static byte ha_logo[] = {
   0xfc, 0x01, 0xe0, 0x03, 0x54, 0x01, 0xf0, 0x07, 0x54, 0x01, 0x38, 0x0e,
   0x54, 0x01, 0xdc, 0x1d, 0x54, 0x01, 0xac, 0x1a, 0x54, 0x03, 0xa6, 0x32,
   0x54, 0x0f, 0xde, 0x3d, 0xd4, 0x1e, 0x6e, 0x3b, 0xb4, 0x3d, 0xb6, 0x36,
   0x74, 0x7b, 0xb6, 0x36, 0x74, 0x77, 0xda, 0x2d, 0x74, 0x77, 0xda, 0x2d,
   0x74, 0x77, 0xda, 0x2d, 0x74, 0x77, 0xda, 0x2d, 0x74, 0x77, 0xda, 0x2d,
   0xfc, 0x7f, 0xfe, 0x3f };
   
static byte hackerspace_text[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xe3, 0xd2, 0x3b,
   0xa4, 0x14, 0x4a, 0x48, 0xbc, 0x17, 0xc6, 0x39, 0xa4, 0x14, 0x4a, 0x28,
   0xa4, 0xe4, 0xd2, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xc0, 0x1d, 0xe3, 0x1e, 0x20, 0xa4, 0x14, 0x02, 0xc0, 0x9c, 0x17, 0x0e,
   0x00, 0x85, 0x14, 0x02, 0xe0, 0x84, 0xe4, 0x1e, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };
   
static byte adelaide_text[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x06, 0x2e, 0x0c, 0x70, 0x69, 0x22, 0x52, 0x13, 0xaf, 0x26, 0x5e, 0x35,
   0xa9, 0x22, 0x52, 0x15, 0x69, 0xee, 0x52, 0x73, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };
   
static byte is_text[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x3f, 0x00,
   0x00, 0x8e, 0x7f, 0x00, 0x00, 0xce, 0xf1, 0x00, 0x00, 0xce, 0xe1, 0x00,
   0x00, 0xce, 0x03, 0x00, 0x00, 0x8e, 0x1f, 0x00, 0x00, 0x0e, 0x7f, 0x00,
   0x00, 0x0e, 0xf8, 0x00, 0x00, 0x0e, 0xe0, 0x00, 0x00, 0xce, 0xc0, 0x00,
   0x00, 0xce, 0xe1, 0x00, 0x00, 0x8e, 0x7f, 0x00, 0x00, 0x0e, 0x3f, 0x00,
   0x00, 0x00, 0x00, 0x00 };
   
static byte in_text[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce, 0xc1, 0x01,
   0x00, 0xce, 0xc3, 0x01, 0x00, 0xce, 0xc3, 0x01, 0x00, 0xce, 0xc7, 0x01,
   0x00, 0xce, 0xcf, 0x01, 0x00, 0xce, 0xcf, 0x01, 0x00, 0xce, 0xdd, 0x01,
   0x00, 0xce, 0xd9, 0x01, 0x00, 0xce, 0xf9, 0x01, 0x00, 0xce, 0xf1, 0x01,
   0x00, 0xce, 0xf1, 0x01, 0x00, 0xce, 0xe1, 0x01, 0x00, 0xce, 0xc1, 0x01,
   0x00, 0x00, 0x00, 0x00 };
   
static byte session_text[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xee, 0x39, 0x97, 0x89,
   0x21, 0x84, 0x50, 0x9a, 0xe6, 0x18, 0x53, 0xaa, 0x28, 0x20, 0x54, 0xca,
   0xe7, 0x9d, 0x93, 0x89, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };
   
static byte format_logo[] = {
   0x00, 0xc0, 0x03, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0xf8, 0x1f, 0x00,
   0x00, 0xf8, 0x1f, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x3f, 0x00,
   0x00, 0xfc, 0x3f, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0xf8, 0x1f, 0x00,
   0x00, 0xf8, 0x1f, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x67, 0xc6, 0x17, 0xe9,
   0x91, 0x0a, 0xb7, 0x55, 0x93, 0x86, 0x51, 0x5d, 0x91, 0xca, 0x10, 0x55,
   0x61, 0x2a, 0x10, 0x55 };
   
void loop(void){
	if(digitalRead(2)){
		hackerspace_in_session_loop();
	}else{
		format_loop();
	}
}


void hackerspace_in_session_loop(){

	dmd.clearScreen( true );

	write_xbitmap(hackerspace_text,64);
	delay(2000);
	write_xbitmap(adelaide_text,64);
	delay(1500);
	write_xbitmap(is_text,64);
	delay(1000);
	write_xbitmap(in_text,64);
	delay(1000);
	write_xbitmap(session_text,64);
	delay(2000);

	// Draw Hackerspace Adelaide Logo
	write_xbitmap(ha_logo,64); 
	delay(5000);
	
	// Run Conway's Game of Life over the logo for 100 iterations.
	for(int i = 0; i<60; i++){
		GOL_run_step();
		delay(50); // Small delay.
	}
	
	// Dissolve to black.
	dissolve(1,2000); //1ms period, 2000 steps - should take 2 seconds.
	
	write_xbitmap(format_logo,64);
	delay(5000);
	//dissolve(1,2000);
	
	// Place 100 random pixels on the screen.
	for (int i=0; i<100; i++){
		random_pixel(1);
		delay(20);
	}
	
	// Run Conway's Game of Life for 100 iterations.
	for(int i = 0; i<100; i++){
		GOL_run_step();
		delay(50); // Small delay.
	}
	dissolve(1,2000);
	
}

void format_loop(){
	write_xbitmap(format_logo,64);
	delay(5000);
	//dissolve(1,2000);
	
	for(int j = 0; j<10; j++){
		// Place 100 random pixels on the screen.
		for (int i=0; i<50; i++){
			random_pixel(1);
			delay(20);
		}
		
		// Run Conway's Game of Life for 100 iterations.
		for(int i = 0; i<100; i++){
			GOL_run_step();
			delay(50); // Small delay.
		}
	}
	
	dissolve(1,2000);
}
